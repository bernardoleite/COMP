options
{
 LOOKAHEAD=1;
 static = false;
}

PARSER_BEGIN(YAL2JVM)
import java.io.* ;
// código Java que invoca o parser
public class YAL2JVM {

public int errors = 0; // use this variable in order to control the maximum of errors (10)
public int line = 0;
public int column = 0;

 public static void main(String args[]) throws ParseException {
// criação do objecto utilizando o constructor com argumento para
// ler do standard input (teclado)
 YAL2JVMTokenManager tm;

  if (args.length<1) {
        System.out.println("Ficheiro não especificado!");
        System.exit(1);
  }
  try{
      java.io.InputStream infile;
      infile = new java.io.FileInputStream(args[0]);
      tm = new   YAL2JVMTokenManager(new SimpleCharStream(infile));
      System.out.println("Ficheiro lido com sucesso!");
      YAL2JVM parser = new YAL2JVM(infile);
      parser.Module();
      System.out.println("Leitura terminada.");
  }
  catch (java.io.FileNotFoundException e) {
      System.out.println("Ficheiro "+args[0]+" não encontrado");
      return;
    }

 }

void error_skipto(int kind) {
  ParseException e = generateParseException();
  System.out.println(e.toString());
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}

void error_control(ParseException e, String expr, int skipKind) {


  if(errors == 0) {
    System.out.println("--->Exception Catched!!! The message: <---");
  }
  if(expr != "0") {

    errors++;
    if(!(line == e.currentToken.next.beginLine && column == e.currentToken.next.beginColumn)) {
      System.out.println("yal2jvm.jj:error: Something went wrong on " + expr);
      System.out.println(e.currentToken.next.image + " <-- Line:" + e.currentToken.next.beginLine + ", column:" + e.currentToken.next.beginColumn);
      System.out.println("Expecting: ");
      for(int i = 0; i < e.expectedTokenSequences.length; i++) {
        for(int j = 0; j < e.expectedTokenSequences[i].length; j++) {
          System.out.println(tokenImage[e.expectedTokenSequences[i][j]]);
        }
      }

      line = e.currentToken.next.beginLine;
      column = e.currentToken.next.beginColumn;
    }

    if(errors > 10) {
      System.out.println("You have at least 10 errors!!!");
      System.exit(1);
    }

    if(skipKind != PVIRG) {
      Token t;
      do {
        t = getNextToken();
    //    System.out.println("Image " + t.image);

      } while (t.kind != skipKind);
    }
  }

}

}
PARSER_END(YAL2JVM)


// símbolos que não devem ser considerados na análise
SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
  | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}
// definição dos tokens (símbolos terminais)
/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

// definição da produção

void Module() : {}
{
  try{
  <MODULE> <ID> <LCHAVETA>
  (LOOKAHEAD(2) Declaration() )* ( Function() )*
  <RCHAVETA>
  }
  catch(ParseException e){
      error_control(e, "Module", PVIRG);
  }

}

void Declaration() : {}
{
  try{
  (LOOKAHEAD(<ID>"[""]") ArrayElement() | ScalarElement() ) ( <ASSIGN> ( ( "[" ArraySize() "]" ) | (
  <ADDSUB_OP> )? <INTEGER> ) )? <PVIRG>
  }
  catch(ParseException e){
      error_control(e, "Declaration", PVIRG);

}

}

void Function() : {}
{
  try{
  ( LOOKAHEAD(3)( <FUNCTION> (LOOKAHEAD(<ID>"[""]") ArrayElement() | ScalarElement() ) <ASSIGN> <ID> <LPAR> (
  Varlist() )? <RPAR> ) | ( <FUNCTION> <ID> <LPAR> ( Varlist() )? <RPAR> ) )
  <LCHAVETA> Stmtlst() <RCHAVETA>
  }
  catch(ParseException e){
      error_control(e, "Function", LPAR);
      Varlist();
      error_control(e, "0", RPAR);
      error_control(e, "0", LCHAVETA);
      Stmtlst();
      error_control(e, "0", RCHAVETA);
  }

}

void Varlist() : {}
{
  try{
  (LOOKAHEAD(2) ArrayElement() | ScalarElement() ) ( <VIRG> (LOOKAHEAD(2) ArrayElement() | ScalarElement() ))*
  }
  catch(ParseException e){
      error_control(e, "Varlist", LCHAVETA);
  }
}

void ArrayElement() : {}
{
  try{
  <ID> "[" "]"
  }
  catch(ParseException e){
      error_control(e, "ArrayElement", PVIRG);
  }
}

void ScalarElement() : {}
{
  try{
  <ID>
  }
  catch(ParseException e){
      error_control(e, "ScalarElement", PVIRG);
  }
}

void Stmtlst() : {}
{
  try{
    ( Stmt() )*
    }
  catch(ParseException e){
      error_control(e, "Stmtlst", RCHAVETA);
    }
}

void Stmt() : {}
{
  try{
  While()
  | If()
  | LOOKAHEAD(3) Assign()
  | Call() <PVIRG>
  }
  catch(ParseException e){
      error_control(e, "Stmt", LCHAVETA);
      Stmtlst(); error_control(e, "0", RCHAVETA);
    }
}

void Assign() : {}
{
  try{
  Lhs() <ASSIGN> Rhs() <PVIRG>
  }
  catch(ParseException e){
      error_control(e, "Assign", PVIRG);
    }
}

void Lhs() : {}
{
  try{
  LOOKAHEAD(<ID>"[") ArrayAccess()
  | ScalarAccess()
  }
  catch(ParseException e){
      error_control(e, "Lhs", PVIRG);
    }
}

void Rhs() : {}
{
  try{
  ( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? )
  | "[" ArraySize() "]"
  }
  catch(ParseException e){
      error_control(e, "Rhs", PVIRG);
    }
}

void ArraySize() : {}
{
  try{
  ScalarAccess()
  | <INTEGER>
  }
  catch(ParseException e){
      error_control(e, "ArraySize", PVIRG);
  }
}

void Term() : {}
{
  try{
  ( <ADDSUB_OP> )? ( <INTEGER> |LOOKAHEAD(3) Call() |LOOKAHEAD(<ID>"[") ArrayAccess() | ScalarAccess() )
  }
  catch(ParseException e){
      error_control(e, "Term", PVIRG);
  }
}

void Exprtest() : {}
{
  try{
  <LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
  }
  catch(ParseException e){
      error_control(e, "Exprtest", RPAR);
  }
}

void While() : {}
{
  try{
  <WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
  }
  catch(ParseException e){
      error_control(e, "While", RCHAVETA);
  }
}

void If() : {}
{
  try{
  <IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> ( <ELSE> <LCHAVETA>
  Stmtlst() <RCHAVETA> )?
  }
  catch(ParseException e){
      error_control(e, "If", PVIRG);
  }
}

void Call() : {}
{
  try{
  <ID> ( "." <ID> )? <LPAR> ( ArgumentList() )? <RPAR>
  }
  catch(ParseException e){
      error_control(e, "Call", PVIRG);
  }
}

void ArgumentList() : {}
{
    try{
    Argument() ( <VIRG> Argument() )*
    }
    catch(ParseException e){
        error_control(e, "ArgumentList", PVIRG);
    }
}

void Argument() : {}
{
  try{
  ( <ID> | <STRING> | <INTEGER> )
  }
  catch(ParseException e){
      error_control(e, "Argument", PVIRG);
  }
}

void ArrayAccess() : {}
{
  try{
  <ID> "[" Index() "]"
  }
  catch(ParseException e){
      error_control(e, "ArrayAccess", PVIRG);
  }
}

void ScalarAccess() : {}
{
  try{
  <ID> ( "." <SIZE> )?
  }
  catch(ParseException e){
      error_control(e, "ScalarAccess", PVIRG);
  }
}

void Index() : {}
{
  try {
  <ID>
  | <INTEGER>
  }
  catch(ParseException e){
      error_control(e, "Index", PVIRG);
  }
}
